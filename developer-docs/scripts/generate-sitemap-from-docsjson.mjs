// developer-docs/scripts/generate-sitemap-from-docsjson.mjs
import fs from "node:fs";
import path from "node:path";

/**
 * Generates sitemap.xml for a Mintlify project by respecting docs.json navigation.
 *
 * Intended usage (run from the Mintlify project root, i.e. developer-docs/):
 *   SITE_URL=https://docs.example.com node scripts/generate-sitemap-from-docsjson.mjs
 *
 * ENV (all optional except SITE_URL strongly recommended):
 *  - SITE_URL:           Base URL of your docs site (e.g., https://docs.getalchemystai.com)
 *  - DOCS_JSON:          Path to docs.json relative to project root (default: docs.json)
 *  - DOCS_DIR:           Content directory relative to project root (default: docs)
 *  - SITEMAP_OUT_DIR:    Output directory relative to project root (default: .)
 *  - INCLUDE_ORPHANS:    "true" to also include all mdx/md files not in navigation (default: false)
 *  - INCLUDE_UNRESOLVED: "true" to include nav routes even if they don't resolve to a local file
 *                       (useful for API reference routes generated by Mintlify) (default: false)
 *  - EXCLUDE_DIRS:       Comma-separated list of directory names to exclude (default set below)
 *  - EXCLUDE_FILES:      Comma-separated list of file basenames to exclude (default set below)
 */

const PROJECT_ROOT = process.cwd();

const SITE_URL = (process.env.SITE_URL || "https://getalchemystai.com/docs").replace(/\/+$/, "");
const DOCS_JSON = process.env.DOCS_JSON || "docs.json";
const DOCS_DIR = process.env.DOCS_DIR || "docs";
const OUT_DIR = process.env.SITEMAP_OUT_DIR || ".";
const INCLUDE_ORPHANS = String(process.env.INCLUDE_ORPHANS || "false").toLowerCase() === "true";
const INCLUDE_UNRESOLVED = String(process.env.INCLUDE_UNRESOLVED || "true").toLowerCase() === "true";

const DEFAULT_EXCLUDE_DIRS = [
  "node_modules",
  ".git",
  ".github",
  "dist",
  "build",
  ".next",
  ".vercel",
  ".turbo",
];
const DEFAULT_EXCLUDE_FILES = ["README.mdx"];

const EXCLUDE_DIRS = new Set(
  (process.env.EXCLUDE_DIRS ? process.env.EXCLUDE_DIRS.split(",") : DEFAULT_EXCLUDE_DIRS)
    .map((s) => s.trim())
    .filter(Boolean)
);
const EXCLUDE_FILES = new Set(
  (process.env.EXCLUDE_FILES ? process.env.EXCLUDE_FILES.split(",") : DEFAULT_EXCLUDE_FILES)
    .map((s) => s.trim())
    .filter(Boolean)
);

function abs(p) {
  return path.isAbsolute(p) ? p : path.join(PROJECT_ROOT, p);
}

function readJson(filePath) {
  const full = abs(filePath);
  if (!fs.existsSync(full)) throw new Error(`docs.json not found at: ${full}`);
  return JSON.parse(fs.readFileSync(full, "utf8"));
}

function isExcluded(fullPath) {
  const parts = fullPath.split(path.sep);
  return parts.some((p) => EXCLUDE_DIRS.has(p));
}

function walk(dir) {
  const out = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, entry.name);
    if (isExcluded(full)) continue;

    if (entry.isDirectory()) out.push(...walk(full));
    else out.push(full);
  }
  return out;
}

function normalizeRoute(route) {
  if (!route) return null;

  let r = String(route).trim();
  if (!r) return "/";

  // If it looks like an absolute URL, we don't include it in sitemap.
  if (/^https?:\/\//i.test(r)) return null;

  // Strip hash and query
  r = r.split("#")[0].split("?")[0];

  // Normalize slashes
  r = r.replace(/^\/+/, "");
  r = r.replace(/\/+$/, "");

  if (r === "" || r === "index") return "/";

  return `/${r}`;
}

/**
 * Traverse docs.json navigation defensively and collect routes.
 * Supports:
 *  - strings inside arrays (pages)
 *  - objects with path/href/route
 *  - nested keys like navigation.tabs.groups.pages, etc.
 */
function collectRoutesFromNav(node, out) {
  if (node == null) return;

  if (typeof node === "string") {
    const p = normalizeRoute(node);
    if (p) out.add(p);
    return;
  }

  if (Array.isArray(node)) {
    for (const item of node) collectRoutesFromNav(item, out);
    return;
  }

  if (typeof node === "object") {
    // Common page descriptors
    if (typeof node.path === "string") {
      const p = normalizeRoute(node.path);
      if (p) out.add(p);
    }
    if (typeof node.href === "string") {
      const p = normalizeRoute(node.href);
      if (p) out.add(p);
    }
    if (typeof node.route === "string") {
      const p = normalizeRoute(node.route);
      if (p) out.add(p);
    }

    // Common nesting keys in Mintlify docs.json
    const candidateKeys = [
      "navigation",
      "tabs",
      "groups",
      "pages",
      "items",
      "dropdowns",
      "children",
      "sections",
    ];

    for (const key of candidateKeys) {
      if (node[key] != null) collectRoutesFromNav(node[key], out);
    }
  }
}

function routeToCandidates(urlPath) {
  const docsRoot = abs(DOCS_DIR);

  if (urlPath === "/") {
    return [
      path.join(docsRoot, "index.mdx"),
      path.join(docsRoot, "index.md"),
      path.join(docsRoot, "home.mdx"),
      path.join(docsRoot, "home.md"),
    ];
  }

  const rel = urlPath.replace(/^\/+/, ""); // "guides/getting-started"
  return [
    path.join(docsRoot, `${rel}.mdx`),
    path.join(docsRoot, `${rel}.md`),
    path.join(docsRoot, rel, "index.mdx"),
    path.join(docsRoot, rel, "index.md"),
  ];
}

function resolveRouteToFile(urlPath) {
  for (const f of routeToCandidates(urlPath)) {
    if (fs.existsSync(f) && fs.statSync(f).isFile()) {
      if (EXCLUDE_FILES.has(path.basename(f))) return null;
      return f;
    }
  }
  return null;
}

function fileToUrlPath(filePath) {
  const docsRoot = abs(DOCS_DIR);
  const rel = path.relative(docsRoot, filePath);

  if (!rel || rel.startsWith("..")) return null;
  if (!(rel.endsWith(".mdx") || rel.endsWith(".md"))) return null;
  if (EXCLUDE_FILES.has(path.basename(rel))) return null;

  const base = rel.replace(/\.(mdx|md)$/, "");
  let urlPath = "/" + base.split(path.sep).join("/");

  if (urlPath === "/index") urlPath = "/";
  if (urlPath.endsWith("/index")) urlPath = urlPath.slice(0, -"/index".length) || "/";

  return urlPath.replace(/\/{2,}/g, "/");
}

function escapeXml(s) {
  return s
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&apos;");
}

function buildSitemap(urlPaths) {
  const now = new Date().toISOString();

  const body = [...urlPaths]
    .filter(Boolean)
    .sort()
    .map((p) => {
      const loc = `${SITE_URL}${p === "/" ? "" : p}`;
      return `  <url>
    <loc>${escapeXml(loc)}</loc>
    <lastmod>${now}</lastmod>
  </url>`;
    })
    .join("\n");

  return `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${body}
</urlset>
`;
}

function main() {
  const docsJson = readJson(DOCS_JSON);

  // Prefer docsJson.navigation if present; otherwise traverse the entire object.
  const navRoot = docsJson?.navigation ?? docsJson;

  const navRoutes = new Set();
  collectRoutesFromNav(navRoot, navRoutes);

  const included = new Set();
  const unresolved = [];

  for (const urlPath of navRoutes) {
    const file = resolveRouteToFile(urlPath);
    if (file) {
      included.add(urlPath);
    } else if (INCLUDE_UNRESOLVED) {
      // include things like API reference routes that don't map to a local file
      included.add(urlPath);
    } else {
      unresolved.push(urlPath);
    }
  }

  if (INCLUDE_ORPHANS) {
    const docsRoot = abs(DOCS_DIR);
    if (!fs.existsSync(docsRoot)) {
      throw new Error(`DOCS_DIR not found: ${docsRoot}`);
    }
    const files = walk(docsRoot).filter((f) => f.endsWith(".mdx") || f.endsWith(".md"));
    for (const f of files) {
      const p = fileToUrlPath(f);
      if (p) included.add(p);
    }
  }

  const outPath = path.join(abs(OUT_DIR), "sitemap.xml");
  fs.writeFileSync(outPath, buildSitemap(included), "utf8");

  console.log(`Generated sitemap.xml with ${included.size} URLs at ${outPath}`);

  if (unresolved.length) {
    console.log(
      `Skipped ${unresolved.length} nav routes that did not resolve to local .mdx/.md (set INCLUDE_UNRESOLVED=true to include them):\n` +
      unresolved.map((r) => ` - ${r}`).join("\n")
    );
  }
}

main();
